axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
print(intraClusterSplitMedianPlot)
#####Manually adapt
cutoffForOligoclonality <- 9
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
clusterSplits
distance
distance[which(clusterIdentityofdistance == 3)]
wbcStatus
clusterSplits
posteriorSamplingFile <-  "../../input_folder/Pr9/Pr9_1M_10_seed27825_postSampling.tsv"
countFile <- "../../input_folder/Pr9/Pr9.txt"
descriptionFile <- "../../input_folder/Pr9/Pr9_samples_nodeDescription.tsv"
treeName <- "Pr9"
sourceCpp('mutations_placement.cpp')
find_most_recent_common_ancestor <- function(treeParentVectorFormat, leaf1, leaf2){
##Trace back the lineage of the tree for one leaf.
##Then trace back the lineage of the tree for the other leaf and for every node
##whether is lies in the lineage of the first leaf.
##The first node that does is the most recent common ancestor node.
##Concatenating these two will form the shortest path through the tree.
## If there is a mutation on the tree, then this means that the cells are
##split by the tree, if there is none, then they aren't.
##Note that the nodes and leaves of the tree are encoded from 0 to the number of nodes minus 1
## Therefore, I add 1 to the indices to be compatible with R indication starting at 1
lineage1 <- leaf1
repeat {
#print(treeParentVectorFormat[lineage1[length(lineage1)] + 1])
lineage1 <- c(lineage1, treeParentVectorFormat[lineage1[length(lineage1)] + 1])
if(lineage1[length(lineage1)] == length(treeParentVectorFormat)) break
}
lineage2 <- leaf2
nextParent <- treeParentVectorFormat[leaf2 + 1]
while(!(nextParent %in% lineage1))  {
lineage2 <- c(lineage2, nextParent)
nextParent <- treeParentVectorFormat[nextParent + 1]
#print(nextParent)
#print(!(nextParent %in% lineage1))
}
MRCA <- nextParent
return(list(lineage1,lineage2, MRCA))
}
postSampling <- read_delim(posteriorSamplingFile,
delim = "\t", col_names = c("LogScore", "SequencingErrorRate","DropoutRate", "LogTau", "Tree"))
counts <- read_delim(countFile,
delim = "\t", col_names = FALSE)
description <- read_delim(descriptionFile,
delim = "\t", col_names = c("Cluster", "CellCount", "TCs", "WBCs", "Description"))
nCells <- sum(description$CellCount)
nClusters <- nrow(description)
nMutations <- nrow(counts)
alleleCount <- description$CellCount*2
##The Cluster-ID maps cells identities to the cell-clusters they belong to.
##The i-th entry having value x means that
## Cells i is in cluster description$Cluster[j]
ClusterID <- vector()
for(i in 1:nClusters) ClusterID <- c(ClusterID, rep.int(i-1,description$CellCount[i]))
## Note that Cpp counts arrays from zero, so the cluster IDs are counted likewise
## in order to be compatible with Cpp code.
##Pull apart the count file into counts for mutated read and total counts respectively
mutatedReadCounts <- matrix(0,nrow = nMutations, ncol = 0)
for (j in 1:nClusters){
mutatedReadCounts <- cbind(mutatedReadCounts,counts[,4+2*j])
}
wildtypeReadCounts <- matrix(0,nrow = nMutations, ncol = 0)
for (j in 1:nClusters){
wildtypeReadCounts <- cbind(wildtypeReadCounts,counts[,4+2*j-1])
}
totalReadCounts <- mutatedReadCounts + wildtypeReadCounts
mutatedReadCounts <- mutatedReadCounts %>% t() %>% as.data.frame() %>% as.list()
wildtypeReadCounts <- wildtypeReadCounts %>% t() %>% as.data.frame() %>% as.list()
totalReadCounts <- totalReadCounts %>% t() %>% as.data.frame() %>% as.list()
##wbc status indicates which of the cells is a white blood cells and which one isn't.
##So far, the cells are arbitrary, and I will assign the fist cells from a cluster to be WBCs.
wbcStatus <- rep(0, nCells)
for(i in 1:nClusters){
j <- 1
while(j <= description$WBCs[i]){ #Iterating over the number of White blood cells of a cluster
wbcStatus[which(ClusterID == i-1)[1] + j-1] <- 1 # and identifying the first cell
# that belongs to a cluster and counting from then on
## Note: The cluster IDs are counted from zero!
j<- j+1
}
}
compute_pairwise_distance_of_leaves <- function(treeData, leaf1, leaf2){
tree <- treeData$Tree
treeParentVectorFormat <- as.numeric(unlist(strsplit(tree, " ")))
dropoutRate <- treeData$DropoutRate
seqErrRate <- treeData$SequencingErrorRate
### Now I need to compute the best mutation placement on the tree. This is done
##using the scoreTree C++ function (taken from CTC_treeScoring.cpp).
ancestorMatrix <- parentVector2ancMatrix(treeParentVectorFormat,
length(treeParentVectorFormat))
bestMutationPlacement <- getMutationPlacement (nCells, nMutations, nClusters,
ancestorMatrix, alleleCount,
ClusterID,mutatedReadCounts,
totalReadCounts,
dropoutRate, seqErrRate, 1,
wbcStatus)
pairwiseGenealogy <- find_most_recent_common_ancestor(treeParentVectorFormat, leaf1,leaf2)
positionOfMRCA <- which(pairwiseGenealogy[[1]] == pairwiseGenealogy[[3]])
firstLeafToMRCA <- pairwiseGenealogy[[1]][1:(positionOfMRCA)]
secondLeafToMRCA <- pairwiseGenealogy[[2]]
#print(firstLeafToMRCA)
#print(secondLeafToMRCA)
pathBetweenLeaves <- c(firstLeafToMRCA,rev(secondLeafToMRCA))
#print(pathBetweenLeaves)
## Now count an output how many of the mutations lie in the shortest path between the leaves.
##This equals the Hamming distance between the inferred Genotypes of two leaves
##Need to exclude the MRCA for this
return(sum(bestMutationPlacement %in% pathBetweenLeaves[pathBetweenLeaves != firstLeafToMRCA[positionOfMRCA]]))
}
produce_Distance_Posterior <- function(leaf1, leaf2,treePosterior, treeName){
## For each row in the posterior Sampling file, the distance of two leaves is computed
dist_histogram <- sapply(split(postSampling, seq(nrow(postSampling))),FUN = compute_pairwise_distance_of_leaves, leaf1, leaf2)
median_dist <- median(dist_histogram)
postProbabilityOfLengths <- c(postProbabilityOfLengths, sum(postSampling$PostDistr[which(dist_histogram == i)]))
plot(
ggplot(data.frame(HammingDistance = dist_histogram), aes(x = HammingDistance)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "black", alpha = 0.7)+
xlab(sprintf("genetic distance between leaf %d and leaf %d", leaf1, leaf2)) + ylab("total count") +
ggtitle(paste("Histogram of genetic distances of clusters cells in", treeName)) +
geom_vline(xintercept = median_dist,color = "red", linetype = "dashed", size = 1) +
labs(subtitle = "As sampled from the posterior distribution",caption = "median indicated by dashed red line") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16)
)
)
return(median(dist_histogram))
}
## Go through all clusters an compare all pairs of cells within each cluster with
## each other. Note that the cells from the clusters are adjacent to each other by
## design, so incrementing the index j by 1 makes sense
distance <- vector()
clusterIdentityofdistance <- vector()
for (c in 1:nClusters){
cellsInCluster <- which(ClusterID == (c-1))-1 ## Make sure array indication is
## compatible with cpp
for(i in cellsInCluster){
j <- cellsInCluster[1]
while(j < i){
print(paste(paste("Computing genomic distances of leaves:", i, sep = " "), j, sep = " "))
distance <- c(distance, produce_Distance_Posterior(i,j,treePosterior, treeName))
clusterIdentityofdistance <- c(clusterIdentityofdistance, c-1)
j <- j + 1
}
}
}
produce_Distance_Posterior <- function(leaf1, leaf2,treePosterior, treeName){
## For each row in the posterior Sampling file, the distance of two leaves is computed
dist_histogram <- sapply(split(postSampling, seq(nrow(postSampling))),FUN = compute_pairwise_distance_of_leaves, leaf1, leaf2)
median_dist <- median(dist_histogram)
plot(
ggplot(data.frame(HammingDistance = dist_histogram), aes(x = HammingDistance)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "black", alpha = 0.7)+
xlab(sprintf("genetic distance between leaf %d and leaf %d", leaf1, leaf2)) + ylab("total count") +
ggtitle(paste("Histogram of genetic distances of clusters cells in", treeName)) +
geom_vline(xintercept = median_dist,color = "red", linetype = "dashed", size = 1) +
labs(subtitle = "As sampled from the posterior distribution",caption = "median indicated by dashed red line") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16)
)
)
return(median(dist_histogram))
}
## Go through all clusters an compare all pairs of cells within each cluster with
## each other. Note that the cells from the clusters are adjacent to each other by
## design, so incrementing the index j by 1 makes sense
distance <- vector()
clusterIdentityofdistance <- vector()
for (c in 1:nClusters){
cellsInCluster <- which(ClusterID == (c-1))-1 ## Make sure array indication is
## compatible with cpp
for(i in cellsInCluster){
j <- cellsInCluster[1]
while(j < i){
print(paste(paste("Computing genomic distances of leaves:", i, sep = " "), j, sep = " "))
distance <- c(distance, produce_Distance_Posterior(i,j,treePosterior, treeName))
clusterIdentityofdistance <- c(clusterIdentityofdistance, c-1)
j <- j + 1
}
}
}
intraClusterSplitMedianPlot <- ggplot(data.frame(Median_Distance = distance), aes(x = Median_Distance)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "black", alpha = 0.7)+
xlab("Median distance between of leaves within the same cluster") + ylab("total count") +
ggtitle(treeName) +
labs(subtitle = "Histogram of similarities of cells within cluster",caption = "dashed red line indicates cutoff for oligoclonality") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
print(intraClusterSplitMedianPlot)
#####Manually adapt
cutoffForOligoclonality <- 9
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
### Now look at each cluster and determine whether at least one pair of cells split
clusterSplits <- vector()
for (c in 1:nClusters){
cellPairsInCluster <- which(clusterIdentityofdistance == (c-1))
print(cellPairsInCluster)
print("Distances:")
print(distance[cellPairsInCluster])
if(length(cellPairsInCluster) == 0) next
else if (max(distance[cellPairsInCluster])>cutoffForOligoclonality){
clusterSplits <- c(clusterSplits,1)
}
else {
clusterSplits <- c(clusterSplits,0)
}
}
if (max(distance[cellsInCluster])>cutoffForOligoclonality){
print("YES")
}
print(sum(clusterSplits)/length(clusterSplits))
posteriorSamplingFile <-  "../../input_folder/LM2/LM2_1M_10_seed10956_postSampling.tsv"
countFile <- "../../input_folder/LM2/LM2.txt"
descriptionFile <- "../../input_folder/LM2/LM2_samples_nodeDescription.tsv"
treeName <- "LM2"
find_most_recent_common_ancestor <- function(treeParentVectorFormat, leaf1, leaf2){
##Trace back the lineage of the tree for one leaf.
##Then trace back the lineage of the tree for the other leaf and for every node
##whether is lies in the lineage of the first leaf.
##The first node that does is the most recent common ancestor node.
##Concatenating these two will form the shortest path through the tree.
## If there is a mutation on the tree, then this means that the cells are
##split by the tree, if there is none, then they aren't.
##Note that the nodes and leaves of the tree are encoded from 0 to the number of nodes minus 1
## Therefore, I add 1 to the indices to be compatible with R indication starting at 1
lineage1 <- leaf1
repeat {
#print(treeParentVectorFormat[lineage1[length(lineage1)] + 1])
lineage1 <- c(lineage1, treeParentVectorFormat[lineage1[length(lineage1)] + 1])
if(lineage1[length(lineage1)] == length(treeParentVectorFormat)) break
}
lineage2 <- leaf2
nextParent <- treeParentVectorFormat[leaf2 + 1]
while(!(nextParent %in% lineage1))  {
lineage2 <- c(lineage2, nextParent)
nextParent <- treeParentVectorFormat[nextParent + 1]
#print(nextParent)
#print(!(nextParent %in% lineage1))
}
MRCA <- nextParent
return(list(lineage1,lineage2, MRCA))
}
postSampling <- read_delim(posteriorSamplingFile,
delim = "\t", col_names = c("LogScore", "SequencingErrorRate","DropoutRate", "LogTau", "Tree"))
counts <- read_delim(countFile,
delim = "\t", col_names = FALSE)
description <- read_delim(descriptionFile,
delim = "\t", col_names = c("Cluster", "CellCount", "TCs", "WBCs", "Description"))
nCells <- sum(description$CellCount)
nClusters <- nrow(description)
nMutations <- nrow(counts)
alleleCount <- description$CellCount*2
##The Cluster-ID maps cells identities to the cell-clusters they belong to.
##The i-th entry having value x means that
## Cells i is in cluster description$Cluster[j]
ClusterID <- vector()
for(i in 1:nClusters) ClusterID <- c(ClusterID, rep.int(i-1,description$CellCount[i]))
## Note that Cpp counts arrays from zero, so the cluster IDs are counted likewise
## in order to be compatible with Cpp code.
##Pull apart the count file into counts for mutated read and total counts respectively
mutatedReadCounts <- matrix(0,nrow = nMutations, ncol = 0)
for (j in 1:nClusters){
mutatedReadCounts <- cbind(mutatedReadCounts,counts[,4+2*j])
}
wildtypeReadCounts <- matrix(0,nrow = nMutations, ncol = 0)
for (j in 1:nClusters){
wildtypeReadCounts <- cbind(wildtypeReadCounts,counts[,4+2*j-1])
}
totalReadCounts <- mutatedReadCounts + wildtypeReadCounts
mutatedReadCounts <- mutatedReadCounts %>% t() %>% as.data.frame() %>% as.list()
wildtypeReadCounts <- wildtypeReadCounts %>% t() %>% as.data.frame() %>% as.list()
totalReadCounts <- totalReadCounts %>% t() %>% as.data.frame() %>% as.list()
##wbc status indicates which of the cells is a white blood cells and which one isn't.
##So far, the cells are arbitrary, and I will assign the fist cells from a cluster to be WBCs.
wbcStatus <- rep(0, nCells)
for(i in 1:nClusters){
j <- 1
while(j <= description$WBCs[i]){ #Iterating over the number of White blood cells of a cluster
wbcStatus[which(ClusterID == i-1)[1] + j-1] <- 1 # and identifying the first cell
# that belongs to a cluster and counting from then on
## Note: The cluster IDs are counted from zero!
j<- j+1
}
}
compute_pairwise_distance_of_leaves <- function(treeData, leaf1, leaf2){
tree <- treeData$Tree
treeParentVectorFormat <- as.numeric(unlist(strsplit(tree, " ")))
dropoutRate <- treeData$DropoutRate
seqErrRate <- treeData$SequencingErrorRate
### Now I need to compute the best mutation placement on the tree. This is done
##using the scoreTree C++ function (taken from CTC_treeScoring.cpp).
ancestorMatrix <- parentVector2ancMatrix(treeParentVectorFormat,
length(treeParentVectorFormat))
bestMutationPlacement <- getMutationPlacement (nCells, nMutations, nClusters,
ancestorMatrix, alleleCount,
ClusterID,mutatedReadCounts,
totalReadCounts,
dropoutRate, seqErrRate, 1,
wbcStatus)
pairwiseGenealogy <- find_most_recent_common_ancestor(treeParentVectorFormat, leaf1,leaf2)
positionOfMRCA <- which(pairwiseGenealogy[[1]] == pairwiseGenealogy[[3]])
firstLeafToMRCA <- pairwiseGenealogy[[1]][1:(positionOfMRCA)]
secondLeafToMRCA <- pairwiseGenealogy[[2]]
#print(firstLeafToMRCA)
#print(secondLeafToMRCA)
pathBetweenLeaves <- c(firstLeafToMRCA,rev(secondLeafToMRCA))
#print(pathBetweenLeaves)
## Now count an output how many of the mutations lie in the shortest path between the leaves.
##This equals the Hamming distance between the inferred Genotypes of two leaves
##Need to exclude the MRCA for this
return(sum(bestMutationPlacement %in% pathBetweenLeaves[pathBetweenLeaves != firstLeafToMRCA[positionOfMRCA]]))
}
#This case is particularly interesting, because the result is bimodal
dist_histogram <- sapply(split(postSampling, seq(nrow(postSampling))),FUN = compute_pairwise_distance_of_leaves, 9, 10)
produce_Distance_Posterior <- function(leaf1, leaf2,treePosterior, treeName){
## For each row in the posterior Sampling file, the distance of two leaves is computed
dist_histogram <- sapply(split(postSampling, seq(nrow(postSampling))),FUN = compute_pairwise_distance_of_leaves, leaf1, leaf2)
median_dist <- median(dist_histogram)
plot(
ggplot(data.frame(HammingDistance = dist_histogram), aes(x = HammingDistance)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "black", alpha = 0.7)+
xlab(sprintf("genetic distance between leaf %d and leaf %d", leaf1, leaf2)) + ylab("total count") +
ggtitle(paste("Histogram of genetic distances of clusters cells in", treeName)) +
geom_vline(xintercept = median_dist,color = "red", linetype = "dashed", size = 1) +
labs(subtitle = "As sampled from the posterior distribution",caption = "median indicated by dashed red line") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16)
)
)
return(median(dist_histogram))
}
produce_Distance_Posterior(19,20, postSampling, treeName)
produce_Distance_Posterior(0,9, postSampling)
treeName <- "LM2"
## Go through all clusters an compare all pairs of cells within each cluster with
## each other. Note that the cells from the clusters are adjacent to each other by
## design, so incrementing the index j by 1 makes sense
distance <- vector()
clusterIdentityofdistance <- vector()
for (c in 1:nClusters){
cellsInCluster <- which(ClusterID == (c-1))-1 ## Make sure array indication is
## compatible with cpp
for(i in cellsInCluster){
j <- cellsInCluster[1]
while(j < i){
print(paste(paste("Computing genomic distances of leaves:", i, sep = " "), j, sep = " "))
distance <- c(distance, produce_Distance_Posterior(i,j,treePosterior, treeName))
clusterIdentityofdistance <- c(clusterIdentityofdistance, c-1)
j <- j + 1
}
}
}
intraClusterSplitMedianPlot <- ggplot(data.frame(Median_Distance = distance), aes(x = Median_Distance)) +
geom_histogram(binwidth = 1, fill = "skyblue", color = "black", alpha = 0.7)+
xlab("Median distance between of leaves within the same cluster") + ylab("total count") +
ggtitle(treeName) +
labs(subtitle = "Histogram of similarities of cells within cluster",caption = "dashed red line indicates cutoff for oligoclonality") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
print(intraClusterSplitMedianPlot)
intraClusterSplitMedianPlot <- ggplot(data.frame(Median_Distance = distance), aes(x = Median_Distance)) +
geom_histogram(binwidth = 5, fill = "skyblue", color = "black", alpha = 0.7)+
xlab("Median distance between of leaves within the same cluster") + ylab("total count") +
ggtitle(treeName) +
labs(subtitle = "Histogram of similarities of cells within cluster",caption = "dashed red line indicates cutoff for oligoclonality") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
intraClusterSplitMedianPlot <- ggplot(data.frame(Median_Distance = distance), aes(x = Median_Distance)) +
geom_histogram(binwidth = 10, fill = "skyblue", color = "black", alpha = 0.7)+
xlab("Median distance between of leaves within the same cluster") + ylab("total count") +
ggtitle(treeName) +
labs(subtitle = "Histogram of similarities of cells within cluster",caption = "dashed red line indicates cutoff for oligoclonality") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
intraClusterSplitMedianPlot <- ggplot(data.frame(Median_Distance = distance), aes(x = Median_Distance)) +
geom_histogram(binwidth = 20, fill = "skyblue", color = "black", alpha = 0.7)+
xlab("Median distance between of leaves within the same cluster") + ylab("total count") +
ggtitle(treeName) +
labs(subtitle = "Histogram of similarities of cells within cluster",caption = "dashed red line indicates cutoff for oligoclonality") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
print(intraClusterSplitMedianPlot)
intraClusterSplitMedianPlot <- ggplot(data.frame(Median_Distance = distance), aes(x = Median_Distance)) +
geom_histogram(binwidth = 10, fill = "skyblue", color = "black", alpha = 0.7)+
xlab("Median distance between of leaves within the same cluster") + ylab("total count") +
ggtitle(treeName) +
labs(subtitle = "Histogram of similarities of cells within cluster",caption = "dashed red line indicates cutoff for oligoclonality") +
theme_minimal() +
theme(
plot.title = element_text(size = 24, face = "bold"),
axis.title.x = element_text(size = 20),
axis.title.y = element_text(size = 20),
plot.subtitle = element_text(size= 20),
axis.text = element_text(size = 16),
plot.caption = element_text(size = 14)
)
print(intraClusterSplitMedianPlot)
#####Manually adapt
cutoffForOligoclonality <- 10
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
#####Manually adapt
cutoffForOligoclonality <- 100
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
#####Manually adapt
cutoffForOligoclonality <- 200
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
print(intraClusterSplitMedianPlot)
#####Manually adapt
cutoffForOligoclonality <- 100
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
print(intraClusterSplitMedianPlot)
#####Manually adapt
cutoffForOligoclonality <- 100
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
print(intraClusterSplitMedianPlot)
intraClusterSplitMedianPlot
summary(distance)
#####Manually adapt
cutoffForOligoclonality <- 100
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
#####Manually adapt
cutoffForOligoclonality <- 400
intraClusterSplitMedianPlot + geom_vline(xintercept = cutoffForOligoclonality,color = "red", linetype = "dashed", size = 1)
### Now look at each cluster and determine whether at least one pair of cells split
clusterSplits <- vector()
for (c in 1:nClusters){
cellPairsInCluster <- which(clusterIdentityofdistance == (c-1))
print(cellPairsInCluster)
print("Distances:")
print(distance[cellPairsInCluster])
if(length(cellPairsInCluster) == 0) next
else if (max(distance[cellPairsInCluster])>cutoffForOligoclonality){
clusterSplits <- c(clusterSplits,1)
}
else {
clusterSplits <- c(clusterSplits,0)
}
}
clusterSplits
print(sum(clusterSplits)/length(clusterSplits))
distance[which(clusterIdentityofdistance == 3)]
cluster
print(sum(clusterSplits)/length(clusterSplits))
clusterSplits
length(clusterSplits)
which(clusterSplits == 1)
which(clusterSplits == 0)
clusterID
ClusterID
which(ClusterID == 26)
which(ClusterID == 25)
produce_Distance_Posterior(35,36, postSampling, "LM2")
produce_Distance_Posterior(35,36, postSampling, "LM2")
renv::status()
?renv::status()
